#!/usr/bin/env node

/**
 * Release script for Documentation Crawler Chrome Extension
 *
 * Usage: node rls.js <version>
 * Example: node rls.js 2.2.0
 *
 * This script:
 * 1. Updates manifest.json and popup/package.json with the new version
 * 2. Generates a custom version file with format: <version>.<yymmdd>.<git-sha>
 * 3. Commits all changes (solving the chicken-and-egg problem with commit hash)
 * 4. Tags the commit with the version
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Color helpers for terminal output
const colors = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m'
};

function log(message, color = 'reset') {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

function error(message) {
  log(`‚ùå Error: ${message}`, 'red');
  process.exit(1);
}

function success(message) {
  log(`‚úÖ ${message}`, 'green');
}

function info(message) {
  log(`‚ÑπÔ∏è  ${message}`, 'cyan');
}

function warning(message) {
  log(`‚ö†Ô∏è  ${message}`, 'yellow');
}

/**
 * Validates version format (x.x.x)
 */
function validateVersion(version) {
  const semverRegex = /^\d+\.\d+\.\d+$/;
  if (!semverRegex.test(version)) {
    error(`Invalid version format: ${version}. Expected format: x.x.x (e.g., 2.1.0)`);
  }
}

/**
 * Executes a shell command and returns output
 */
function exec(command, silent = false) {
  try {
    const output = execSync(command, { encoding: 'utf8' });
    return output.trim();
  } catch (err) {
    if (!silent) {
      error(`Command failed: ${command}\n${err.message}`);
    }
    throw err;
  }
}

/**
 * Updates JSON file with new version
 */
function updateJsonFile(filePath, version) {
  try {
    const content = fs.readFileSync(filePath, 'utf8');
    const json = JSON.parse(content);
    json.version = version;
    fs.writeFileSync(filePath, JSON.stringify(json, null, 2) + '\n', 'utf8');
    success(`Updated ${path.basename(filePath)} to version ${version}`);
  } catch (err) {
    error(`Failed to update ${filePath}: ${err.message}`);
  }
}

/**
 * Generates timestamp in YYMMDD format
 */
function generateTimestamp() {
  const now = new Date();
  const yy = String(now.getFullYear()).slice(-2);
  const mm = String(now.getMonth() + 1).padStart(2, '0');
  const dd = String(now.getDate()).padStart(2, '0');
  return `${yy}${mm}${dd}`;
}

/**
 * Generates custom version file
 */
function generateVersionFile(version, gitSha = 'pending', timestamp = null) {
  const now = new Date();
  const ts = timestamp || generateTimestamp();
  const fullVersion = `${version}.${ts}.${gitSha}`;

  const versionFilePath = path.join(__dirname, 'popup', 'src', 'version.ts');

  const content = `/**
 * Auto-generated version file
 * Generated at: ${now.toISOString()}
 * DO NOT EDIT - This file is automatically generated by rls.js
 */

export const VERSION = '${fullVersion}';
export const PACKAGE_VERSION = '${version}';
export const BUILD_TIMESTAMP = '${ts}';
export const GIT_SHA = '${gitSha}';
export const BUILD_DATE = '${now.toISOString()}';
`;

  fs.writeFileSync(versionFilePath, content, 'utf8');
  return { fullVersion, versionFilePath };
}

/**
 * Checks if working directory is clean
 */
function checkGitStatus() {
  try {
    const status = exec('git status --porcelain', true);
    if (status) {
      warning('Working directory has uncommitted changes.');
      info('The following files will be included in the release commit:');
      console.log(status);
      return false;
    }
    return true;
  } catch (err) {
    error('Not in a git repository');
  }
}

/**
 * Main release process
 */
function release(version) {
  log('\nüöÄ Starting release process...', 'blue');
  info(`Target version: ${version}`);

  // Step 1: Validate version
  validateVersion(version);

  // Step 2: Check git status
  checkGitStatus();

  // Step 3: Update manifest.json
  info('\nüìù Updating version files...');
  const manifestPath = path.join(__dirname, 'manifest.json');
  updateJsonFile(manifestPath, version);

  // Step 4: Update popup/package.json
  const popupPackagePath = path.join(__dirname, 'popup', 'package.json');
  updateJsonFile(popupPackagePath, version);

  // Step 5: Stage version files ONLY (not version.ts yet)
  info('\nüì¶ Staging version files for first commit...');
  exec('git add manifest.json');
  exec('git add popup/package.json');
  success('Staged: manifest.json, popup/package.json');

  // Step 6: Create version bump commit (without version.ts)
  info('\nüíæ Creating version bump commit...');
  const commitMessage = `chore: bump version to ${version}

ü§ñ Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>`;

  try {
    // Write commit message to temporary file to handle multi-line properly
    const tmpFile = path.join(__dirname, '.commit-msg-tmp');
    fs.writeFileSync(tmpFile, commitMessage, 'utf8');
    exec(`git commit -F "${tmpFile}"`);
    fs.unlinkSync(tmpFile);
    success('Created version bump commit');
  } catch (err) {
    error('Failed to create commit. Make sure there are changes to commit.');
  }

  // Step 7: Get the commit hash (this is the correct hash we want in version.ts)
  info('\nüîç Getting commit hash...');
  const gitSha = exec('git rev-parse --short=7 HEAD');
  success(`Commit hash: ${gitSha}`);

  // Step 8: Generate version file with the actual commit hash
  info('\nüîß Generating version file with correct commit hash...');
  const timestamp = generateTimestamp();
  const { fullVersion } = generateVersionFile(version, gitSha, timestamp);
  success(`Generated version: ${fullVersion}`);

  // Step 9: Commit version.ts separately
  info('\nüìù Committing version file...');
  exec('git add popup/src/version.ts');
  const versionCommitMessage = `chore: update version file to ${fullVersion}

ü§ñ Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>`;

  try {
    const tmpFile = path.join(__dirname, '.commit-msg-tmp');
    fs.writeFileSync(tmpFile, versionCommitMessage, 'utf8');
    exec(`git commit -F "${tmpFile}"`);
    fs.unlinkSync(tmpFile);
    success('Committed version file');
  } catch (err) {
    warning('Version file might not have changed, skipping commit');
  }

  // Step 10: Get final commit hash for summary
  const finalGitSha = exec('git rev-parse --short=7 HEAD');

  // Step 11: Create git tag
  info('\nüè∑Ô∏è  Creating git tag...');
  const tagName = `v${version}`;
  try {
    exec(`git tag -a ${tagName} -m "Release ${version}"`);
    success(`Created tag: ${tagName}`);
  } catch (err) {
    warning(`Tag ${tagName} might already exist. Skipping tag creation.`);
  }

  // Step 12: Show summary
  log('\n‚ú® Release completed successfully!', 'green');
  info('\nSummary:');
  console.log(`  Version: ${version}`);
  console.log(`  Full version: ${fullVersion}`);
  console.log(`  Version bump commit: ${gitSha}`);
  console.log(`  Version file commit: ${finalGitSha}`);
  console.log(`  Tag: ${tagName}`);

  log('\nüìå Next steps:', 'yellow');
  console.log('  1. Review commits: git log -2 --oneline');
  console.log('  2. Verify version file: cat popup/src/version.ts');
  console.log('  3. Push to remote: git push && git push --tags');
  console.log('  4. Build the extension: cd popup && npm run build');
}

// Parse command line arguments
const args = process.argv.slice(2);
if (args.length === 0) {
  error('No version specified. Usage: node rls.js <version>\nExample: node rls.js 2.2.0');
}

const version = args[0];
release(version);
